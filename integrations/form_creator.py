import sys
import os
import json
import re
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from googleapiclient.errors import HttpError
from core.google_client import get_google_service
from core.logger import logger
import json, re

def create_google_form(assessment_json, title="Auto Assessment"):
    """
    Create a Google Form from assessment JSON generated by AssessmentAgent.
    Configures quiz mode and attempts to auto-collect email.
    Ensures answer keys are applied via post-creation updates.
    """
    try:
        logger.info("Creating Google Form: %s", title)
        service = get_google_service("forms", "v1")

        # Accept JSON string inputs
        if isinstance(assessment_json, str):
            assessment_json = _safe_parse_json_string(assessment_json)
            if isinstance(assessment_json, dict) and assessment_json.get("error"):
                return assessment_json

        if not isinstance(assessment_json, dict) or "questions" not in assessment_json:
            logger.warning("Invalid assessment JSON: %s", assessment_json)
            return {"success": False, "error": "Invalid assessment JSON. Missing 'questions'."}

        form_title = assessment_json.get("title", title)
        default_points = _default_points_from_rubric(assessment_json.get("rubric", []))

        # Create form
        form = service.forms().create(body={"info": {"title": form_title, "documentTitle": form_title}}).execute()
        form_id = form.get("formId")
        if not form_id:
            return {"success": False, "error": "Failed to create Google Form."}

        # Configure quiz and email collection (best-effort)
        try:
            service.forms().batchUpdate(
                formId=form_id,
                body={
                    "requests": [
                        {
                            "updateSettings": {
                                "settings": {"quizSettings": {"isQuiz": True}, "emailCollectionType": "VERIFIED"},
                                "updateMask": "quizSettings.isQuiz,emailCollectionType"
                            }
                        }
                    ]
                }
            ).execute()
        except Exception:
            logger.warning("Quiz/email settings update failed; continuing without it")

        # Helpers
        def _to_list(ans):
            if ans is None:
                return []
            if isinstance(ans, (str, int, float)):
                return [str(ans)]
            if isinstance(ans, list):
                return [str(a).strip() for a in ans if str(a).strip()]
            return []

        def _map_answers_to_options(provided: list[str], options: list[str]) -> list[str]:
            if not options:
                return provided
            out: list[str] = []
            lower_map = {o.lower().strip(): o for o in options}
            for raw in provided:
                s = str(raw).strip()
                if not s:
                    continue
                if s in options and s not in out:
                    out.append(s); continue
                low = s.lower()
                if low in lower_map and lower_map[low] not in out:
                    out.append(lower_map[low]); continue
                if s.isdigit():
                    i = int(s) - 1
                    if 0 <= i < len(options):
                        v = options[i]
                        if v not in out: out.append(v); continue
                if len(s) == 1 and s.isalpha():
                    i = ord(s.upper()) - ord('A')
                    if 0 <= i < len(options):
                        v = options[i]
                        if v not in out: out.append(v); continue
            return out

        # Create items first (no grading to avoid schema issues)
        create_reqs = []
        norm_questions: list[dict] = []
        for idx, q in enumerate(assessment_json.get("questions", [])):
            if isinstance(q, str):
                q = {"q": q, "options": [], "answer": None}
            title_text = (q.get("q") or f"Question {idx+1}").strip()
            opts = q.get("options") or []
            if not isinstance(opts, list):
                opts = [str(opts)]
            clean_opts = []
            seen = set()
            for opt in opts:
                s = str(opt).strip()
                if s and s not in seen:
                    seen.add(s); clean_opts.append(s)
            is_mcq = len(clean_opts) >= 2
            # widen type to allow mixed value types for pylance
            item_question: dict[str, object] = {"required": True}
            if is_mcq:
                item_question["choiceQuestion"] = {"type": "RADIO", "options": [{"value": o} for o in clean_opts], "shuffle": True}
            else:
                item_question["textQuestion"] = {"paragraph": False}
            create_reqs.append({
                "createItem": {
                    "item": {"title": title_text, "questionItem": {"question": item_question}},
                    "location": {"index": idx}
                }
            })
            norm_questions.append({"title": title_text, "options": clean_opts, "answer": q.get("answer")})

        if create_reqs:
            service.forms().batchUpdate(formId=form_id, body={"requests": create_reqs}).execute()

        # Fetch created items and apply grading
        applied_count = 0
        responder_uri = None
        try:
            created = service.forms().get(formId=form_id).execute() or {}
            responder_uri = created.get("responderUri")
            items = [it for it in (created.get("items") or []) if "questionItem" in it]
            update_reqs = []
            for idx, nq in enumerate(norm_questions):
                if idx >= len(items):
                    break
                item = items[idx]
                item_id = item.get("itemId")
                if not item_id:
                    continue
                created_opts = []
                qobj = item.get("questionItem", {}).get("question", {})
                if "choiceQuestion" in qobj:
                    created_opts = [o.get("value") for o in qobj.get("choiceQuestion", {}).get("options", []) if o.get("value")]
                provided = _to_list(nq.get("answer"))
                correct_vals = _map_answers_to_options(provided, created_opts) if created_opts else provided
                if not correct_vals and not provided:
                    continue
                update_reqs.append({
                    "updateItem": {
                        "item": {
                            "itemId": item_id,
                            "questionItem": {"question": {"grading": {"pointValue": default_points, "correctAnswers": {"answers": [{"value": v} for v in correct_vals] if correct_vals else []}}}}
                        },
                        "location": {"index": idx},
                        "updateMask": "questionItem.question.grading"
                    }
                })
            if update_reqs:
                service.forms().batchUpdate(formId=form_id, body={"requests": update_reqs}).execute()
                # Verify
                verify = service.forms().get(formId=form_id).execute() or {}
                for it in verify.get("items", []) or []:
                    qv = it.get("questionItem", {}).get("question", {})
                    grading = qv.get("grading", {}) if isinstance(qv, dict) else {}
                    ca = grading.get("correctAnswers", {}) if isinstance(grading, dict) else {}
                    ans = ca.get("answers", []) if isinstance(ca, dict) else []
                    if isinstance(ans, list) and ans:
                        applied_count += 1
        except Exception as e:
            logger.warning("Post-creation grading update failed: %s", e)

        edit_url = f"https://docs.google.com/forms/d/{form_id}/edit"
        return {
            "success": True,
            "formId": form_id,
            "formUrl": responder_uri,  # public responder URL if available
            "editUrl": edit_url,
            "email_collection": "VERIFIED",
            "answer_keys_applied": applied_count,
        }

    except HttpError as e:
        logger.error("Google Forms API error: %s", e)
        return {"success": False, "error": f"Google Forms API error: {e}"}
    except Exception as e:
        logger.error("Form creation failed: %s", e, exc_info=True)
        return {"success": False, "error": f"Form creation failed: {e}"}


# helpers (same as before)
def _safe_parse_json_string(s: str):
    try:
        cleaned = s.strip()
        m = re.search(r"```(?:json)?\s*([\s\S]*?)```", cleaned, re.IGNORECASE)
        if m:
            cleaned = m.group(1).strip()
        if not cleaned.startswith("{"):
            start, end = cleaned.find("{"), cleaned.rfind("}")
            if start != -1 and end != -1 and end > start:
                cleaned = cleaned[start:end+1]
        return json.loads(cleaned)
    except Exception as e:
        logger.error("Failed to parse assessment_json string: %s", e)
        return {"error": f"Invalid assessment JSON string: {e}"}

def _default_points_from_rubric(rubric):
    try:
        for rule in rubric or []:
            if (rule.get("criteria","").lower().startswith("correct") 
                and isinstance(rule.get("points"), int)):
                return rule["points"]
    except Exception:
        pass
    return 1
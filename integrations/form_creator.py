import sys
import os
import json
import re
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from googleapiclient.errors import HttpError
from core.google_client import get_google_service
from core.logger import logger


def create_google_form(assessment_json, title="Auto Assessment"):
    """
    Create a Google Form from assessment JSON generated by AssessmentAgent.
    Handles errors with structured logging.
    """

    try:
        logger.info("Creating Google Form: %s", title)
        service = get_google_service("forms", "v1")

        # Accept JSON string inputs by parsing into a dict
        if isinstance(assessment_json, str):
            try:
                logger.info("Parsing JSON string input...")
                cleaned = assessment_json.strip()
                logger.debug("Original string length: %d", len(assessment_json))

                # Extract JSON from ```json ... ```
                match = re.search(r"```(?:json)?\s*([\s\S]*?)```", cleaned, re.IGNORECASE)
                if match:
                    cleaned = match.group(1).strip()

                # If not starting with {, try to find JSON boundaries
                if not cleaned.startswith("{"):
                    start, end = cleaned.find("{"), cleaned.rfind("}")
                    if start != -1 and end != -1 and end > start:
                        cleaned = cleaned[start:end + 1]

                assessment_json = json.loads(cleaned)
                logger.info("Successfully parsed JSON string to dict")

            except Exception as e:
                logger.error("Failed to parse assessment_json string: %s", str(e))
                return {"error": f"Invalid assessment JSON string: {str(e)}"}

        # Validate the parsed dict
        if not isinstance(assessment_json, dict):
            logger.warning("Invalid assessment JSON: %s", assessment_json)
            return {"error": "Invalid assessment JSON. Expected a dictionary."}
        
        # Check if this is an error response from the assessment agent
        if "error" in assessment_json:
            logger.error("Assessment generation failed: %s", assessment_json.get("error"))
            return {"error": f"Assessment generation failed: {assessment_json.get('error')}"}
        
        if "questions" not in assessment_json:
            logger.warning("Invalid assessment JSON: %s", assessment_json)
            return {"error": "Invalid assessment JSON. Missing 'questions'."}

        # Use provided title if available
        form_title = assessment_json.get("title", title)

        # Extract default point value from rubric (fallback = 1)
        default_points = 1
        for rule in assessment_json.get("rubric", []):
            if rule.get("criteria", "").lower().startswith("correct"):
                default_points = rule.get("points", 1)
                break

        # Create empty form
        NEW_FORM = {
            "info": {"title": form_title, "documentTitle": form_title}
        }
        form = service.forms().create(body=NEW_FORM).execute()
        form_id = form.get("formId")

        if not form_id:
            logger.error("Form creation returned no formId.")
            return {"error": "Failed to create Google Form."}

        service.forms().batchUpdate(
            formId=form_id,
            body={
            "requests": [
                {
                    "updateSettings": {
                        "settings": {"quizSettings": {"isQuiz": True}},
                        "updateMask": "quizSettings.isQuiz"
                    }
                }
            ]
            }
            ).execute()

        # Prepare batchUpdate requests for questions
        # 3) Build questions (robust: always set a kind or skip)
        batch_requests = []
        questions = assessment_json.get("questions", [])
        for idx, q in enumerate(questions):
            try:
                # Normalize incoming shape
                if isinstance(q, str):
                    q = {"q": q}

                title_text = (q.get("q") or f"Question {idx+1}").strip()

                # Clean options
                raw_opts = q.get("options") or []
                if not isinstance(raw_opts, list):
                    raw_opts = [str(raw_opts)]
                clean_opts = []
                seen = set()
                for opt in raw_opts:
                    s = str(opt).strip()
                    if s and s not in seen:
                        seen.add(s)
                        clean_opts.append(s)

                # Decide question kind
                is_mcq = len(clean_opts) >= 2

                # Normalize answers
                def to_correct_answers_list(ans):
                    if ans is None:
                        return None
                    if isinstance(ans, str):
                        cand = [ans]
                    elif isinstance(ans, list):
                        cand = [str(a).strip() for a in ans if str(a).strip()]
                    else:
                        cand = []
                    if not cand:
                        return None
                    return {"answers": [{"value": v} for v in cand]}

                answer_key = to_correct_answers_list(q.get("answer"))

                # Build question block
                question = {"required": True}

                # Attach grading only if we have answers
                if answer_key:
                    if is_mcq:
                        # Optional sanity: only keep answers that match options
                        allowed = {o for o in clean_opts}
                        filtered = [a for a in answer_key["answers"] if a["value"] in allowed]
                        if filtered:
                            question["grading"] = {
                                "pointValue": default_points,
                                "correctAnswers": {"answers": filtered}
                            }
                        else:
                            # If none match, skip grading for this MCQ to avoid invalid key
                            question["grading"] = {"pointValue": default_points}
                    else:
                        # Short Answer allows arbitrary text correct answers
                        question["grading"] = {
                            "pointValue": default_points,
                            "correctAnswers": answer_key
                        }

                # Set kind (exactly one)
                if is_mcq:
                    question["choiceQuestion"] = {
                        "type": "RADIO",
                        "options": [{"value": opt} for opt in clean_opts],
                        "shuffle": True
                    }
                else:
                    question["textQuestion"] = {"paragraph": False}

                # Final validation: ensure we actually set a kind
                if "choiceQuestion" not in question and "textQuestion" not in question:
                    logger.warning("Skipping Q%d: no valid question kind determined (title=%r)", idx, title_text)
                    continue

                item = {
                    "createItem": {
                        "item": {
                            "title": title_text,
                            "questionItem": {"question": question}
                        },
                        "location": {"index": idx}
                    }
                }
                batch_requests.append(item)

            except Exception as e:
                logger.warning("Skipping invalid question at index %s: %s", idx, e)

        # Execute batch update if we have questions
        if batch_requests:
            try:
                service.forms().batchUpdate(
                    formId=form_id,
                    body={"requests": batch_requests}
                ).execute()
                logger.info("Successfully added %d questions to form", len(batch_requests))
            except Exception as e:
                logger.error("Failed to add questions to form: %s", str(e))
                return {"error": f"Failed to add questions: {str(e)}"}

        form_url = f"https://docs.google.com/forms/d/{form_id}/viewform"
        return {"success": True, "formId": form_id, "questionCount": len(batch_requests), "formUrl": form_url}

    except Exception as e:
        logger.error("Error creating Google Form: %s", str(e))
        return {"error": f"Failed to create Google Form: {str(e)}"}


# Test code - only run if this file is executed directly
if __name__ == "__main__":
    from agents.assessment_agent import AssessmentAgent
    
    asmt_agent = AssessmentAgent()
    
    # Try to generate assessment with retry logic
    max_retries = 3
    assessment = None
    
    for attempt in range(max_retries):
        try:
            print(f"Attempt {attempt + 1} to generate assessment...")
            assessment = asmt_agent.generate_assessment(
                "/home/timmy/ai-teacher-assistant/static/Lecture_Slide.pdf",
                {"type": "ShortAnswer", "difficulty": "Medium", "count": 5, "rubric": True}
            )
            
            # Check if assessment generation was successful
            if isinstance(assessment, dict) and "questions" in assessment:
                print("Assessment generated successfully!")
                break
            elif isinstance(assessment, dict) and "error" in assessment:
                print(f"Assessment generation failed: {assessment['error']}")
                if attempt < max_retries - 1:
                    print("Retrying...")
                    continue
            else:
                print("Unexpected assessment format, retrying...")
                if attempt < max_retries - 1:
                    continue
                    
        except Exception as e:
            print(f"Error during assessment generation: {e}")
            if attempt < max_retries - 1:
                print("Retrying...")
                continue
    
    if assessment and isinstance(assessment, dict) and "questions" in assessment:
        result = create_google_form(assessment, title="SDLC Quiz")
        print("\n---Results---")
        print(result)
        if result.get("success") and result.get("formUrl"):
            print(f"\nGoogle Form URL: {result['formUrl']}")
    else:
        print("\n---Failed to generate assessment---")
        print("Assessment:", assessment)

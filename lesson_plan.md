Great! I’ll take the content you provided and transform it into a **structured lesson plan section** that you can use in a class.  

---

# Lesson Plan Section  
**Course:** Software Engineering  
**Chapter 1:** Introduction to Software Requirements Engineering  
**Instructor:** AJ. Prasara Jakkaew  
**Academic Year:** 2024/01  
**School:** School of Information Technology, Mae Fah Luang University  

---

### Lesson Title:  
**Introduction to Software Requirements Engineering**

---

### Learning Objectives:  
By the end of this lesson, students will be able to:  
1. Define the concept of requirements engineering.  
2. Explain the role of requirements engineering in the Software Development Life Cycle (SDLC).  
3. Describe the process of gathering, analyzing, and documenting requirements.  
4. Understand the purpose of a System Requirements Specification (SRS).  
5. Recognize the importance of requirements engineering in ensuring high-quality software that meets user expectations.  

---

### Key Concepts / Content:  
- **Definition:** Requirements Engineering is the process of gathering, analyzing, and documenting software requirements from clients.  
- **Role in SDLC:** It is usually the first step in the software development life cycle.  
- **Goal:** To create and maintain a detailed System Requirements Specification (SRS).  
- **Importance:** Ensures that the final software product meets user expectations and results in high-quality software.  
- **Reference Resource:** [Medium article on Software Engineering Process Activities](https://medium.com/omarelgabrys-blog/software-engineering-process-activities-part-3-ca1ef6818fd6)  

---

### Teaching Activities:  
1. **Introduction (5 minutes):**  
   - Briefly introduce the topic and its relevance in software development.  
   - Ask students: *“Why do you think requirements are important before coding begins?”*  

2. **Lecture & Explanation (15 minutes):**  
   - Present the definition and role of requirements engineering.  
   - Explain the steps: gathering, analyzing, documenting requirements.  
   - Discuss the purpose of the SRS document.  

3. **Class Discussion (10 minutes):**  
   - Pose a scenario: *“Imagine you are building an app for a client who only says ‘I want a food delivery app.’ What steps would you take to clarify requirements?”*  

4. **Activity (10 minutes):**  
   - In small groups, students list 3–5 possible requirements for a simple

Great! I’ll take your raw notes and convert them into a **structured lesson plan section** that you can use in a classroom or training session.  

---

# Lesson Plan Section: Introduction to Requirements Engineering  

### Lesson Title:  
**Requirements Engineering: Fundamentals and Roles**

---

### Learning Objectives:  
By the end of this lesson, students will be able to:  
1. Define **requirements engineering** and explain its importance in software development.  
2. Identify the key activities involved in requirements engineering.  
3. Recognize the professional roles associated with requirements engineering.  
4. Explain the consequences of developing software without proper requirements.  

---

### Lesson Content:  

#### 1. Introduction (5 minutes)  
- Begin by asking: *“What happens if a software project starts without clear requirements?”*  
- Highlight the goal: to understand how requirements engineering ensures high-quality software.  

---

#### 2. What is Requirements Engineering? (10 minutes)  
- Definition: The systematic process of **eliciting, analyzing, documenting, and validating** requirements for a software system.  
- Emphasize that requirements engineering is the foundation of building successful software.  

---

#### 3. Key Activities in Requirements Engineering (15 minutes)  
- **Software Process Model** – how requirements fit into the overall development process.  
- **Requirement Elicitation** – gathering needs from stakeholders.  
- **Requirement Analysis** – refining and prioritizing requirements.  
- **Requirement Documentation** – recording requirements clearly and unambiguously.  
- **Requirement Validation** – ensuring requirements are correct and feasible.  
- **Practical Considerations** – handling real-world challenges such as changing requirements.  

*(Use diagrams or flowcharts to illustrate the process.)*  

---

#### 4. Roles in Requirements Engineering (10 minutes)  
Discuss the professionals who engage in requirements engineering:  
- Software Analyst  
- Business Analyst  
- Process Analyst  
- Business Architect  
- Project Manager  
- Product Manager / Product Owner  
- Quality Assurance Analyst  
- Consultant  

*(Activity: Ask students which of these roles they might interact with in a real project.)*  

---

#### 5. Why Requirements Matter (10 minutes)  
Without requirements:  
- Developers don’t know when the product is “done.”  
- Testers don’t know what to test.  
- Customers don’t know what to expect.  
- Users cannot determine if the software meets their needs.  

*(Class discussion: Share real-world examples of failed projects due to poor

Great! I’ll take your raw notes and convert them into a **structured lesson plan section** that could fit into a software engineering or systems development course. I’ll organize it into **objectives, key concepts, teaching activities, and discussion prompts** so it’s ready to use in a classroom.  

---

# Lesson Plan Section: Importance of Correct Requirements in Software Development  

### Learning Objectives
By the end of this lesson, students will be able to:  
1. Explain the consequences of unclear or invalid requirements in software projects.  
2. Identify how errors in requirements propagate through later stages of development.  
3. Connect the relationship between requirements and project constraints (time, cost, scope, and risk).  
4. Differentiate between outcomes of correct vs. faulty specifications.  

---

### Key Concepts
1. **Unclear Requirements**  
   - Testers have no idea what to test.  
   - Customers do not know what to expect.  
   - Users cannot determine if the software will meet their needs.  

2. **Invalid Requirements**  
   - Can lead to a non-useful system.  
   - Cause major changes and schedule delays, increasing cost.  
   - Introduce unnecessary steps, reducing usability and efficiency.  
   - Result in overly complicated, unusable systems.  

3. **Project Management Impact**  
   - Poor requirements affect the "Iron Triangle":  
     - **Time** (delays)  
     - **Cost** (budget overruns)  
     - **Scope** (unnecessary or missing features)  
     - **Risk** (higher chance of failure)  

4. **Propagation of Errors**  
   - **Correct Requirement → Correct Specification → Correct Design → Correct Programs → Correct Functions**  
   - **Faulty Requirement → Faulty Specification → Faulty Design → Faulty Programs → Faulty Functions**  
   - Errors at the requirement stage multiply as they move downstream.  

---

### Teaching Activities
1. **Case Study Discussion (10 min)**  
   Present a short scenario of a project with vague requirements (e.g., “The system should be user-friendly”). Ask students:  
   - What problems might arise during testing?  
   - How would this affect the customer and end-users?  

2. **Group Activity: Requirement Analysis (15 min)**  
   - Divide students into groups.  
   - Provide each group with one “requirement” (some valid, some invalid).  
   - Have them identify whether it is valid or invalid

Great! You’ve provided a structured outline that looks like it’s about **software development stages and error propagation**. I’ll convert this into a clear **lesson plan section** that a teacher could use in class.  

---

# Lesson Plan Section: Propagation of Errors in Software Development

### Grade/Level:
Undergraduate Computer Science / Software Engineering (Years 1–2)

### Duration:
45–60 minutes

---

## Learning Objectives
By the end of this lesson, students will be able to:
1. Identify the main stages of software development (Specification, Design, Programming, Functions).  
2. Explain how errors introduced at one stage can propagate to later stages.  
3. Differentiate between correctable and uncorrectable errors.  
4. Analyze examples of faulty specifications, designs, and programs to understand their impact.  

---

## Key Concepts
1. **Specification** – The requirements and intended behavior of the system.  
2. **Design** – The structured plan or architecture based on the specification.  
3. **Programming** – The implementation of the design in code.  
4. **Functions** – The actual behavior of the running program.  
5. **Error Propagation** – Mistakes at earlier stages (e.g., faulty specification) carry forward, creating faulty designs, faulty programs, and incorrect functions.  
6. **Correctable vs. Uncorrectable Errors** – Some errors can be fixed at later stages, while others require revisiting earlier stages.  

---

## Teaching Sequence

### 1. Introduction (5 min)
- Begin with a question: *“If you misunderstand the problem you’re solving, what happens to your program even if your code is perfect?”*  
- Introduce the concept of **error propagation** in software development.

---

### 2. Development Stages & Error Sources (15 min)
- Present the stages in order:  
  - **Correct Specification → Correct Design → Correct Programs → Correct Functions**  
- Show how errors at each stage affect later stages:  
  - Faulty Specification → Faulty Design → Faulty Programs → Faulty Functions  
  - Faulty Design → Faulty Programs → Faulty Functions  
  - Faulty Programs → Faulty Functions  

*Teaching Strategy:* Use a flow diagram to illustrate how mistakes cascade.

---

### 3. Propagation of Errors (15 min)
- Case 1: **Correct Specification, Faulty Functions**  
  - Programming errors cause incorrect functions even if the specification and design are correct

Great! I’ll take your notes and restructure them into a **clear, teacher-friendly lesson plan section**. This will be suitable for a Software Engineering or Requirements Engineering class.  

---

# Lesson Plan Section: Errors in Software Development & Importance of Requirements Engineering  

### Lesson Title:  
Error Propagation in Software Development and the Role of Requirements Engineering  

### Duration:  
45–60 minutes  

---

## Learning Objectives:  
By the end of this lesson, students will be able to:  
1. Identify different sources of errors in software development (specification, design, programming).  
2. Distinguish between correctable, uncorrectable, and hidden errors.  
3. Explain how errors propagate through the software development lifecycle.  
4. Understand the importance of Requirements Engineering in preventing errors.  

---

## Teaching Content:  

### Part 1: Sources of Errors in Software Development  
- **Faulty Specification**: Errors introduced when requirements are unclear, incomplete, or incorrect.  
- **Faulty Design**: Errors that occur when the design is based on faulty specifications or poor design decisions.  
- **Programming Errors**: Mistakes made during coding, either due to misunderstanding the design or human error.  

### Part 2: Types of Errors  
- **Correctable Errors**: Can be detected and fixed during development or testing.  
- **Uncorrectable Errors**: Fundamental flaws (e.g., wrong requirements) that cannot be fixed without major rework.  
- **Hidden Errors**: Remain undetected until later stages or even after deployment.  

### Part 3: Propagation of Errors  
- Errors at one stage (e.g., specification) propagate to later stages (design, coding, testing).  
- Example: A faulty requirement leads to a faulty design, which leads to faulty code, resulting in imperfect software.  

### Part 4: Why Requirements Engineering is Needed  
- **Clarity Before Building**: Ensures everyone knows what is being built before coding starts.  
- **Documented Foundation**: Provides a clear reference for developers, testers, and stakeholders.  
- **Baseline for Development**: Serves as a benchmark for design, coding, and testing.  

---

## Teaching Strategies:  
- **Lecture with Diagram**: Show a flow diagram of error propagation (Specification → Design → Code → Software).  
- **Class Discussion**: Ask students to share real-life examples of software failures due to unclear requirements.  
- **Think-Pair-Share**: Students

Great! I’ll take your provided notes and convert them into a **structured lesson plan section** that you can use in a classroom or training session.  

---

# Lesson Plan Section: Introduction to Requirements Engineering  

### Lesson Title: Importance of Requirements Engineering in Software Development  

**Grade/Level:** Undergraduate Computer Science / Software Engineering Course  
**Duration:** 30–40 minutes  

---

### Learning Objectives  
By the end of this lesson, students will be able to:  
1. Define what Requirements Engineering (RE) is and explain its purpose.  
2. Identify why Requirements Engineering is essential in the software development lifecycle.  
3. Describe how RE supports effort estimation, software evolution, and documentation.  
4. Relate Requirements Engineering to project constraints and success.  

---

### Key Concepts / Content  
1. **Definition of Requirements Engineering**  
   - A documented foundation that clearly defines what the software product is expected to do.  
   - Establishes a **baseline for capabilities**, ensuring all stakeholders understand functionality and scope.  

2. **Why We Need Requirements Engineering**  
   - **Effort Estimation:** Enables accurate prediction of time, resources, and cost.  
   - **Facilitation of Future Evolution:** Supports adaptation, migration, and scalability of software.  
   - **Support for Documentation:** Provides a foundation for technical writers to create user manuals and guides.  

3. **Connection to Project Constraints**  
   - Requirements Engineering helps manage the six classic project constraints: scope, time, cost, quality, resources, and risk.  

---

### Teaching Activities  
**1. Warm-Up (5 minutes):**  
- Ask students: *“What problems might occur if a software project begins without clearly defined requirements?”*  
- Collect responses and connect them to the need for Requirements Engineering.  

**2. Direct Instruction (10 minutes):**  
- Present the definition and importance of Requirements Engineering using slides or a whiteboard.  
- Highlight the three main benefits (effort estimation, evolution, documentation).  

**3. Guided Practice (10 minutes):**  
- Case Study Discussion: Present a short scenario of a failed project due to unclear requirements.  
- In small groups, students identify which aspects of RE could have prevented the failure.  

**4. Wrap-Up & Reflection (5 minutes):**  
- Summarize key points.  
- Ask students to reflect: *“Which benefit of Requirements Engineering do you think is most critical, and why?”*  

---

### Assessment / Evaluation  
-

Great! I’ll take the raw notes you provided and convert them into a structured **lesson plan section** that could fit into a broader unit on **Project Management or Software Requirements Engineering**.  

---

# Lesson Plan Section: Understanding Requirements in Project Management

### Lesson Title:
What Do Requirements Define?

### Grade/Level:
Undergraduate (Project Management / Software Engineering course)  
Could also be adapted for professional training workshops.

---

### Learning Objectives:
By the end of this lesson, students will be able to:  
1. Identify the six key areas that requirements define in a project.  
2. Explain how functional and capability characteristics translate into system features.  
3. Recognize the qualities of excellent requirements (complementary, complete, actionable).  
4. Connect requirements to project constraints and overall project success.

---

### Key Content:
**1. Requirements Define the Following:**  
- **Functional and capability characteristics** – What the system must do.  
- **Type of users and roles** – Who will use the system and in what capacity.  
- **External interfaces** – How the system interacts with other software or hardware.  
- **Safety and security specifications** – Safeguards and compliance needs.  
- **Human factors for the user interface** – Usability, accessibility, and design considerations.  
- **Data definition and database** – Data structures, storage, and management.  

**2. Characteristics of Excellent Requirements:**  
- **Complementary Relationship** – Each requirement maps to a specific system capability.  
- **Complete** – Requirements must fully describe the need without ambiguity or gaps.  
- (Additional qualities such as consistency, feasibility, and testability can be introduced in discussion.)  

---

### Teaching Activities:
1. **Lecture/Presentation (10 min):**  
   - Introduce the six areas requirements define.  
   - Provide real-world examples (e.g., a mobile banking app’s login security, user roles, and database).  

2. **Class Discussion (10 min):**  
   - Ask: *“Why is it important for requirements to be complete and complementary?”*  
   - Small groups brainstorm examples of incomplete requirements and their risks.  

3. **Case Study Activity (15 min):**  
   - Present a short project scenario (e.g., building an e-commerce website).  
   - Students identify requirements in each of the six categories.  
   - Groups share findings with the class.  

---

### Assessment / Check for Understanding:
- **Quick Quiz (5 min

Great! I’ll take your provided text and reframe it into a **lesson plan section** that’s structured, clear, and ready for teaching.  

---

# Lesson Plan Section: Understanding Software Requirements  

### Lesson Objective  
Students will be able to explain what software requirements define, identify the qualities of good requirements, and describe different user roles and their expectations from a system.  

---

### Key Concepts  

**1. Characteristics of Good Requirements**  
- **Complete**: Each requirement must fully describe the functionality to be delivered, providing enough detail for developers to design and implement it.  
- **Correct**: Each requirement must accurately describe the functionality to be built.  
- **Feasible**: Each requirement must be realistic and achievable within the system’s capabilities and constraints.  
- **Prioritized**: Each requirement should have a priority level (e.g., high, medium, low) to indicate its importance for a product release.  

**2. What Do Requirements Define?**  
- The **type of users** who will interact with the system.  
- The **roles** these users will have.  
- The **expectations** of each role regarding the software.  

**Examples of User Roles:**  
- **End User**: What tasks or goals they expect to accomplish.  
- **Administrator**: What control, management, or configuration actions they can perform.  

---

### Teaching Activities  

1. **Discussion Prompt**:  
   - Ask students: *“Why is it important for requirements to be complete and feasible? What might happen if they are not?”*  

2. **Group Activity**:  
   - Divide students into small groups. Assign each group a sample software (e.g., an online bookstore, a learning management system).  
   - Have them identify at least two user roles (e.g., customer, admin, teacher, student).  
   - For each role, write one requirement that is complete, correct, feasible, and prioritized.  

3. **Class Share-Out**:  
   - Groups present their requirements.  
   - Discuss whether they meet the four qualities of good requirements.  

---

### Assessment / Check for Understanding  
- **Exit Ticket**: Students answer:  
  1. What are the four qualities of a good requirement?  
  2. Give one example of what an admin role might expect from a software system.  

---

### Materials Needed  
- Whiteboard or slides with definitions  
- Handouts with requirement qualities  
- Example scenarios for group

Great! I’ll take your raw notes and convert them into a **structured lesson plan section** that can be used in a teaching context. I’ll make it clear, organized, and ready for classroom delivery.  

---

# Lesson Plan Section: **Users, Roles, and External Interfaces in Software Requirements**

### Lesson Objectives
By the end of this section, students will be able to:
1. Identify different types of users and their roles in a software system.  
2. Explain what each role expects from the software.  
3. Describe what software requirements define in terms of external interfaces.  
4. Recognize examples of external systems and how they interact with software.  

---

### Part 1: Users and Roles

**Key Concepts**
- A *user role* defines what a particular type of user can do in the system.  
- Different roles have different permissions and expectations.  

**Discussion Questions**
- What does an administrator expect from the software?  
- What does a typical (regular) user expect?  
- What does a guest user expect?  
- Can you think of other roles (e.g., manager, auditor, customer support)?  

**Teaching Strategy**
- Present a simple software example (e.g., an online learning platform).  
- Ask students to brainstorm what each role (admin, teacher, student, guest) can do.  
- Record responses in a table:  

| Role        | Permissions / Expectations |
|-------------|----------------------------|
| Admin       | Manage users, configure system, access all data |
| Typical User| Use core features, manage own account |
| Guest       | Limited access, view-only features |
| Others      | Role-specific actions |

---

### Part 2: What Requirements Define – External Interfaces

**Key Concepts**
- Requirements describe not only what the system does internally but also how it interacts with external entities.  
- *External interfaces* = connections between the software and outside systems, users, or devices.  

**Examples of External Interfaces**
- Other software systems (e.g., HR system, payroll system, banking system).  
- APIs and web services.  
- Databases.  
- Hardware devices.  
- Human users via presentation services (UI).  

**Visual Aid (to draw on board or slide)**
```
[Human Resource System] ↔ [Our Software] ↔ [Payroll System]
[Bank] ↔ [Our Software] ↔ [Suppliers]
[Executive Info System] ↔ [Our Software]
```

**Activity

Great! I’ll take your provided content and transform it into a structured **lesson plan section**. This will make it classroom-ready, with objectives, activities, and discussion prompts.  

---

# Lesson Plan Section: What Do Requirements Define?  

### Topic Focus: Safety & Security Specifications and Human Factors for the User Interface  

---

### Learning Objectives:  
By the end of this lesson, students will be able to:  
1. Explain the role of safety and security specifications in system requirements.  
2. Identify strategies used to safeguard systems against threats and ensure service continuity.  
3. Describe the importance of human factors in designing user interfaces.  
4. Evaluate how requirements balance functionality, security, and usability.  

---

### Key Concepts:  
- **Systems & Interactions**: Requirements apply to systems, APIs, web services, hardware devices, databases, and even human users.  
- **Safety and Security Specifications**: Define measures and procedures to protect operations, prevent threats, and ensure reliable service delivery.  
- **Human Factors in UI**: Requirements ensure the interface is user-friendly, accessible, and tailored to user needs.  

---

### Teaching Activities:  

**1. Direct Instruction (10 minutes)**  
- Present examples of system requirements that include safety/security measures (e.g., backup servers, encryption, firewalls).  
- Explain how requirements also address human factors, such as intuitive navigation, accessibility, and minimizing user errors.  

**2. Guided Discussion (10 minutes)**  
- Ask: *What could happen if safety and security requirements are ignored?*  
- Ask: *What challenges arise if human factors are not considered in UI design?*  

**3. Case Study Activity (15 minutes)**  
- Provide a short scenario: A web service that must handle sensitive user data while remaining easy to use.  
- Students work in small groups to identify:  
  - Safety/security requirements (e.g., data encryption, redundancy).  
  - Human factor requirements (e.g., clear error messages, simple navigation).  
- Groups share their findings with the class.  

**4. Reflection (5 minutes)**  
- Students write a quick response: *Which is harder to balance—security or usability? Why?*  

---

### Assessment:  
- Participation in discussion and group activity.  
- Reflection response demonstrating understanding of trade-offs between safety/security and usability.  

---

### Materials Needed:  
- Whiteboard or slides with examples of requirements.  
- Case study handout or digital scenario description.  

---



Great! I’ll take the raw text you provided and reframe it into a **structured lesson plan section** that a teacher could use in class. I’ll keep it clear, organized, and instructional.  

---

# Lesson Plan Section: Understanding Software Requirements  

### Topic: Requirements Definition and Classification  

---

### Learning Objectives  
By the end of this lesson, students will be able to:  
1. Explain what requirements define in a software system.  
2. Differentiate between business requirements and user requirements.  
3. Describe the role of data definitions and database specifications in requirements gathering.  
4. Recognize the importance of user interface (UI) considerations in requirements.  

---

### Key Concepts  

1. **User Interface (UI) Requirements**  
   - Ensure the system is not only functional but also user-friendly.  
   - Tailored to meet the specific needs of its users.  

2. **What Do Requirements Define?**  
   - Requirements outline the expected behavior, constraints, and specifications of a system.  
   - They include:  
     - **Data Definition and Database Specifications**  
       - Example: First name field length = 32 characters.  
       - Dates must follow a specific format (e.g., DDMMYYYY).  
       - Other rules for how data is stored, retrieved, and validated.  

3. **Requirement Classification**  
   - **Business Requirements**  
     - Define the overall goals, objectives, or needs of the enterprise.  
     - Explain why a project has started.  
   - **User Requirements**  
     - Describe the needs of specific stakeholders or user groups.  
     - Explain what stakeholders want and how they will interact with the system.  

---

### Teaching Strategies  
- **Direct Instruction:** Present examples of business vs. user requirements.  
- **Class Discussion:** Ask students to brainstorm possible data definitions for a student registration system.  
- **Guided Practice:** Students classify sample requirements into *business* or *user* categories.  
- **Think-Pair-Share:** Students discuss why UI requirements are critical for system adoption.  

---

### Example Activity  
**Scenario:** You are designing a library management system.  
- Write one **business requirement** (e.g., why the system is needed).  
- Write one **user requirement** (e.g., how a librarian or student will use it).  
- Define one **data requirement** (e.g., maximum length of a book title).  

---

### Assessment / Check for Understanding  
- Exit

Got it! You’d like this content reshaped into a **lesson plan section** that is clear, structured, and ready to use in teaching. Here’s a polished version:  

---

# Lesson Plan Section: Understanding Requirements in System Development

### Lesson Title:
Types of Requirements in Software/System Development

### Learning Objectives:
By the end of this lesson, students will be able to:  
1. Identify different types of requirements in system development (business, user, and system).  
2. Differentiate between **functional** and **non-functional** requirements.  
3. Explain how stakeholders interact with a solution and influence requirements.  
4. Organize requirements into high-level and detailed categories.  

---

### Key Concepts & Content:

1. **Stakeholders and Users**  
   - Definition: Individuals or groups who have an interest in the system.  
   - Role: Stakeholders express needs and expectations that shape the solution.  
   - Interaction: They use the system directly or benefit indirectly from its outcomes.  

2. **Types of Requirements**  
   - **Business Requirements**  
     - High-level goals of the organization.  
     - Define *why* the system is needed.  

   - **User Requirements**  
     - Describe what users need from the system.  
     - Focus on *what* the user wants to achieve.  

   - **System Requirements**  
     - Translate business and user needs into system features.  
     - Divided into:  
       - **Functional Requirements**: What the system must do (e.g., allow users to log in, generate reports).  
       - **Non-Functional Requirements**: Conditions under which the system operates (e.g., performance, security, memory, speed).  

3. **Levels of Requirements**  
   - **High-Level Requirements**: Broad, strategic goals.  
   - **Detailed Requirements**: Specific, technical descriptions for implementation.  

---

### Teaching Strategies:
- **Direct Instruction**: Present definitions and examples with diagrams (e.g., requirement hierarchy chart).  
- **Guided Discussion**: Ask students to brainstorm stakeholders for a familiar system (e.g., a school learning management system).  
- **Case Study/Example**: Walk through a simple software solution (e.g., an online food ordering app) and identify business, user, and system requirements.  

---

### Activities:
1. **Stakeholder Mapping Exercise**  
   - Students list possible stakeholders for a given system (e.g., hospital management system).  


Great! I’ll take your notes and convert them into a **structured lesson plan section** that you can use in a teaching session.  

---

# Lesson Plan Section: Understanding Requirements in Software Engineering  

**Class Start Time:** 9:25 AM  

---

### 1. Lesson Title  
Understanding Requirements: Types, Functional vs. Non-Functional  

---

### 2. Learning Objectives  
By the end of this lesson, students will be able to:  
- Differentiate between **business, user, and system requirements**.  
- Explain the difference between **high-level and detailed requirements**.  
- Define and distinguish between **functional requirements (FR)** and **non-functional requirements (NFR)**.  
- Identify examples of FRs and NFRs in a software project.  

---

### 3. Key Concepts & Content  

**A. Requirements Types**  
- **Business Requirements** – Why is the project needed? (strategic goals, business value)  
- **User Requirements** – What do users need the system to do? (user tasks, goals, interactions)  
- **System Requirements** – What does the system need to do? (technical specifications, constraints)  

**B. Levels of Requirements**  
- **High-level Requirements** – Broad goals and needs.  
- **Detailed Requirements** – Specific, measurable, and testable requirements.  

**C. Functional vs. Non-Functional Requirements**  
- **Functional Requirements (FR):**  
  - Define what the system must or must not do.  
  - Describe system behaviors, functions, services, or tasks.  
  - Each function typically includes:  
    - **Input parameters** (conditions)  
    - **Behavior** (processing logic)  
    - **Output** (result)  

- **Non-Functional Requirements (NFR):**  
  - Define system qualities and constraints.  
  - Examples: performance, security, usability, scalability, reliability.  
  - Focus on *how* the system performs rather than *what* it does.  

---

### 4. Teaching & Learning Activities  

**Introduction (5 min)**  
- Quick discussion: *“Why do you think requirements are important in software projects?”*  
- Write student responses on the board.  

**Concept Delivery (15 min)**  
- Present the three types of requirements (Business, User, System).  
- Use a real-world example (e.g., an online shopping app) to illustrate each type.  
- Explain high

Great! I’ll take your draft notes and convert them into a **structured lesson plan section** that could fit into a larger unit on Software Engineering or Systems Analysis.  

---

# Lesson Plan Section: Functional vs. Non-Functional Requirements  

### Lesson Title: Understanding Functional and Non-Functional Requirements  

**Grade/Level:** Undergraduate Computer Science / Software Engineering (or advanced high school CS)  
**Duration:** 30–40 minutes  

---

### Learning Objectives  
By the end of this lesson, students will be able to:  
1. Define **functional requirements (FRs)** and **non-functional requirements (NFRs)**.  
2. Identify the key components of a functional requirement (input, behavior, output).  
3. Explain the role of non-functional requirements as quality attributes or performance stipulations.  
4. Differentiate between examples of FRs and NFRs in real-world software systems.  

---

### Key Concepts  
- **Functional Requirement (FR):**  
  - Specifies *what* the system should do.  
  - Every function includes:  
    - **Input parameter** (a set of conditions)  
    - **Behavior** (calculation, algorithm, process, user interface activity, etc.)  
    - **Output** (a set of responses)  

- **Non-Functional Requirement (NFR):**  
  - Specifies *how* the system should perform.  
  - Defines quality attributes, performance criteria, or constraints.  
  - Examples:  
    - “The response time must be less than 1 second.”  
    - “The system should handle 20 million users without performance decrease.”  

---

### Teaching Activities  

**1. Introduction (5 minutes)**  
- Begin with a short scenario: *“Imagine you are designing an online shopping app. What must the app do? How well must it perform?”*  
- Use student responses to introduce the distinction between FRs and NFRs.  

**2. Direct Instruction (10 minutes)**  
- Present definitions of FRs and NFRs.  
- Show the three-part structure of a functional requirement (input → behavior → output).  
- Explain that NFRs are measurable quality goals (performance, scalability, security, usability, etc.).  
- Display a reference diagram (e.g., FR vs. NFR comparison chart).  

**3. Guided Practice (10 minutes)**  
- Provide students with sample requirements. Example:  
  - “The system shall allow users to reset their password via

Great! I’ll take your notes and restructure them into a **lesson plan section** that you can use in a classroom or training session. I’ll make it clear, structured, and ready to teach.  

---

# Lesson Plan Section: Functional and Non-Functional Requirements  

### Lesson Title: Understanding Functional Requirements in Software Systems  

**Grade/Level:** Undergraduate / Software Engineering Course  
**Duration:** 30–40 minutes  

---

### Learning Objectives  
By the end of this lesson, students will be able to:  
1. Define functional requirements in software systems.  
2. Explain the role of input, process, and output in functional requirements.  
3. Identify functional requirements in real-world examples (e.g., library system, online shopping cart).  
4. Differentiate between functional and non-functional requirements (to be expanded in the next section).  

---

### Key Concepts  
- **System Functions {fi}:** Every system performs a set of functions, each transforming input data into output data.  
- **Functional Requirements:** Describe what the system should do (specific behaviors, tasks, or functions).  
- **Examples:**  
  - **Library Management System**  
    - Input: Book name  
    - Function: Search book  
    - Output: Book details and location in the library  
  - **Online Shopping Cart**  
    - Input: User selects an item and clicks "Add to Cart"  
    - Function: System adds item to cart in the database  
    - Output: Cart display updates with item and new total  

---

### Teaching Activities  

**1. Introduction (5 minutes)**  
- Begin with a question: *“When you use an app or website, what specific actions do you expect it to perform for you?”*  
- Guide students to recognize that these actions are **functional requirements**.  

**2. Direct Instruction (10 minutes)**  
- Present the definition: Functional requirements specify *what the system should do*.  
- Explain the **input → function → output** model.  
- Use the **Library Management System** example to illustrate.  

**3. Guided Practice (10 minutes)**  
- Walk through the **Online Shopping Cart** example step by step.  
- Ask students: *“What is the input here? What does the system do? What is the output?”*  
- Reinforce the structure: Input → Function → Output.  

**4. Independent/Group Activity (10 minutes)**  
- Divide students into small groups.  
- Give them a scenario

Great! I’ll take your provided notes and convert them into a **structured lesson plan section**. This will make it classroom-ready and easy to follow.  

---

# Lesson Plan Section: Functional Requirements (Technique) – Functional Decomposition & Work Breakdown Structures (WBS)

### Lesson Objective:
Students will be able to explain the concept of functional decomposition and Work Breakdown Structures (WBS), and apply the technique to break down a complex process into smaller, manageable components.  

---

### Lesson Content:

**1. Introduction (5 minutes)**  
- Begin with a simple example (e.g., ordering food in an app).  
- Demonstrate how a system can be broken down:  
  - *Play to show the added item and the new total.*  
- Connect this to the idea of functional decomposition: breaking down a large function into smaller, understandable parts.  

---

**2. Key Concepts (10 minutes)**  
- **Definition:**  
  - Functional decomposition or WBS is a **visual document** that illustrates how complex processes break down into simpler components.  
- **Benefits:**  
  - Allows independent analysis of each part.  
  - Ensures the full picture of the project is captured.  
  - Provides clarity for project planning and execution.  

---

**3. Steps in Functional Decomposition (10 minutes)**  
Introduce the **logic of decomposition**:  
- High-Level Function → Sub-function → Process → Activity  

**Step-by-step method:**  
1. Identify the most general function.  
2. Break it down into the closest sub-functions.  
3. Continue breaking down into the next level of sub-functions.  
4. Review and check the diagram for completeness and accuracy.  

---

**4. Visual Example (5 minutes)**  
- Show a sample WBS diagram (e.g., from www.process.st or a teacher-created example).  
- Walk students through how the diagram represents the breakdown of a project.  

---

**5. Guided Practice (10 minutes)**  
- As a class, choose a familiar process (e.g., planning a birthday party, building a website, or preparing a meal).  
- Work together to create a WBS on the board:  
  - Start with the high-level function.  
  - Break it down step by step into sub-functions, processes, and activities.  

---

**6. Independent/Group Activity (15 minutes)**  
- Students work in small groups to create their own WBS for a given scenario (e.g., designing a mobile app,

Great! I’ll take your notes and convert them into a **structured lesson plan section** that you can use in a classroom or training session.  

---

# Lesson Plan Section: Functional and Non-Functional Requirements  

### Lesson Title: Understanding Functional Decomposition and Non-Functional Requirements  

**Grade/Level:** Undergraduate / Professional Training  
**Duration:** 45–60 minutes  

---

### Learning Objectives  
By the end of this lesson, students will be able to:  
1. Explain the concept of functional decomposition and its role in requirements analysis.  
2. Differentiate between functional and non-functional requirements.  
3. Construct a simple functional decomposition diagram (Work Breakdown Structure).  
4. Identify examples of non-functional requirements (quality attributes) in real-world systems.  

---

### Key Concepts  

1. **Functional Decomposition**  
   - Breaking down a **high-level function** into smaller, more manageable parts.  
   - Hierarchy: **High-Level Function → Sub-function → Process → Activity**  
   - Often represented as a **Work Breakdown Structure (WBS)**.  

   **Example Structure:**  
   - Project  
     - Function 1  
       - Sub-function 1.1  
       - Sub-function 1.2  
     - Function 2  
       - Sub-function 2.1  
         - Sub-function 2.1.1  
         - Sub-function 2.1.2  
       - Sub-function 2.2  
     - Function 3  
       - Sub-function 3.1  
       - Sub-function 3.3  

2. **Non-Functional Requirements (NFRs)**  
   - Also known as **quality attributes** or the “-ilities” (e.g., scalability, reliability, usability).  
   - Define **how** the system performs rather than **what** it does.  
   - Examples:  
     - *Performance*: How fast does the system return results?  
     - *Scalability*: How does performance change with higher workloads?  
     - *Security, availability, maintainability, usability*, etc.  

---

### Teaching Activities  

1. **Introduction (5 minutes)**  
   - Briefly explain the difference between functional and non-functional requirements.  
   - Use a simple analogy (e.g., *Functional = what a car does: drive, brake, steer; Non-functional = how well it does it: speed, safety, comfort*).  

2. **Direct Instruction (15 minutes)**  
  

Great! I’ll take your provided content and reframe it into a structured **lesson plan section** that could be used in a classroom or training session on **Non-Functional Requirements (NFRs)** in software engineering.  

---

# Lesson Plan Section: Non-Functional Requirements – Performance, Scalability, Portability, and Compatibility

### Lesson Title:
Understanding Non-Functional Requirements: Performance, Scalability, Portability, and Compatibility

### Learning Objectives:
By the end of this lesson, students will be able to:
1. Define and explain the importance of non-functional requirements (NFRs) in software systems.  
2. Differentiate between performance, scalability, portability, and compatibility.  
3. Analyze examples of NFRs and evaluate their impact on system design and user experience.  
4. Apply NFR concepts to real-world scenarios by drafting measurable requirements.  

---

### Lesson Content:

#### 1. Introduction to Non-Functional Requirements (5 minutes)
- Briefly review the difference between **functional** and **non-functional** requirements.  
- Highlight that NFRs describe *how* a system performs rather than *what* it does.  

---

#### 2. Performance (10 minutes)
- **Definition:** Measures the system’s response time under different load conditions.  
- **Key Question:** How much will performance change with higher workloads?  
- **Example:**  
  *The landing page supporting 5,000 users/hour must provide a response time of 6 seconds or less in Chrome desktop, including rendering text and images.*  
- **Discussion Prompt:** Why is it important to set measurable performance targets?  

---

#### 3. Scalability (10 minutes)
- **Definition:** The system’s ability to handle increasing workloads while maintaining performance.  
- **Key Question:** What is the highest workload under which the system will still meet requirements?  
- **Example:**  
  *The system must be scalable enough to support 1,000,000 simultaneous visits while maintaining optimal performance.*  
- **Activity:** Students brainstorm examples of scalable vs. non-scalable systems they’ve used.  

---

#### 4. Portability (5 minutes)
- **Definition:** The ease with which a system can be transferred from one environment to another (e.g., different operating systems, cloud providers).  
- **Example Discussion:** Why is portability important in today’s multi-platform world?  

---

#### 5. Compatibility (5 minutes)
- **Definition:** The ability of a system to work with other systems

Great! I’ll take your raw notes and convert them into a **structured lesson plan section** that you can use in class. I’ll keep it clear, organized, and ready for teaching.  

---

# Lesson Plan Section: Non-Functional Requirements – Quality Characteristics  

### Lesson Title: Understanding Quality Characteristics in Software Systems  

**Grade/Level:** Undergraduate / Software Engineering Course  
**Duration:** 30–40 minutes  

---

## Learning Objectives
By the end of this lesson, students will be able to:  
1. Define key non-functional quality characteristics of software systems.  
2. Differentiate between **portability**, **compatibility**, **reliability**, **maintainability**, and **availability**.  
3. Provide real-world examples of how these characteristics affect software performance.  
4. Evaluate why these characteristics are critical in software design and development.  

---

## Key Concepts & Content

### 1. Performance and Compatibility  
- **Portability**  
  - Definition: The ability of a system or its components to be launched in different environments without modification.  
  - Example: A program running on Windows 10 should also run on Windows 11 without changes in behavior or performance.  

- **Compatibility**  
  - Definition: The ability of a system to co-exist and operate with other systems in the same environment.  
  - Example: An iOS application should support multiple OS versions (e.g., iOS 14, iOS 15, iOS 16).  

---

### 2. Reliability, Maintainability, Availability  
- **Reliability**  
  - Definition: The probability that software will perform without failure for a specified time or number of uses.  
  - Example: A system must perform without failure in 95% of use cases.  

- **Maintainability**  
  - Definition: The ease with which a system can be modified to correct faults, improve performance, or adapt to a changed environment.  
  - Example: Updating a web application’s codebase to support new security protocols with minimal downtime.  

- **Availability**  
  - Definition: The degree to which a system is operational and accessible when required for use.  
  - Example: An online banking system must be available 99.9% of the time.  

---

## Teaching Strategies
- **Direct Instruction:** Brief lecture with slides to introduce definitions and examples.  
- **Think-Pair-Share:** Students discuss in pairs how a lack of portability or reliability might affect user experience.

Got it! You want me to take that raw text and reframe it into a **lesson plan section** that’s clear, structured, and ready to use in teaching. Here’s a polished version:  

---

### Lesson Plan Section: Non-Functional Requirements – Quality Characteristics  

**Topic:** Non-Functional Requirements (NFRs) – Reliability, Maintainability, Availability, Security, and Usability  

**Learning Objectives:**  
By the end of this section, students will be able to:  
1. Define key non-functional requirements (NFRs) in software systems.  
2. Differentiate between reliability, maintainability, availability, security, and usability.  
3. Provide real-world examples of how each NFR is applied in system design.  

---

**Content Outline:**  

1. **Reliability**  
   - *Definition:* The ability of a system to perform its required functions under stated conditions for a specified period of time.  
   - *Example:* The system must perform without failure in 95% of use cases during a month.  

2. **Maintainability**  
   - *Definition:* The ease, speed, and simplicity with which a system can be restored after a failure.  
   - *Example:* If the system fails, it must be back up and running in less than 10 minutes on average.  

3. **Availability**  
   - *Definition:* The likelihood that the system is operational and accessible to users at any given time.  
   - *Example:* Users must be able to access the web dashboard 99.98% of the time during registration.  

4. **Security**  
   - *Definition:* Ensures that system data and resources are protected from unauthorized access, malware, or breaches.  
   - *Example:* The payment processing gateway must safeguard all transactions against unauthorized access.  

5. **Usability**  
   - *Definition:* The degree to which the system is easy to learn, efficient to use, and satisfying for the user.  
   - *Example:* The registration form should allow new users to complete sign-up within 2 minutes without prior training.  

---

**Teaching Strategies:**  
- **Lecture with Examples:** Present each NFR with real-world scenarios.  
- **Class Discussion:** Ask students to share examples of when they experienced poor reliability, availability, or usability in apps/websites.  
- **Group Activity:** In small groups, students define NFRs for a sample system (e.g., an online food delivery app).

Great! I’ll take the raw notes you provided and convert them into a **structured lesson plan section**. This will make it classroom-ready, with clear objectives, activities, and examples.  

---

# Lesson Plan Section: Functional and Non-Functional Requirements

### Topic:
Understanding Functional vs. Non-Functional Requirements in Software Systems

---

### Learning Objectives:
By the end of this lesson, students will be able to:
1. Differentiate between functional and non-functional requirements.  
2. Provide examples of each type of requirement.  
3. Explain the importance of both requirement types in system design and testing.  

---

### Key Concepts:

**Functional Requirements**  
- **Definition:** Describe *what the product does* (the specific features and functions).  
- **End Result:** Define product features.  
- **Focus:** User requirements (what tasks the system must perform).  
- **Documentation:** Captured in use-case diagrams.  
- **Testing:** Verified through component and system testing.  
- **Example:**  
   - *The payment processing gateway must comply with PCI DSS standards.*  

**Non-Functional Requirements**  
- **Definition:** Describe *how the product works* (the quality attributes of the system).  
- **End Result:** Define product quality attributes.  
- **Focus:** User expectations (usability, performance, reliability, security).  
- **Documentation:** Captured as quality attributes.  
- **Testing:** Verified through performance, security, and usability testing.  
- **Example:**  
   - *The system must be protected against malware attacks or unauthorized access.*  
   - *The error rate of users submitting payment information at checkout must not exceed 10%.*  

---

### Teaching Strategy:
1. **Introduction (5 min):**  
   - Ask students: *“What’s the difference between what a system does and how well it does it?”*  
   - Use a real-world analogy (e.g., a car: functions = drives, brakes, accelerates; non-functional = fuel efficiency, safety, comfort).  

2. **Direct Instruction (10 min):**  
   - Present the definitions, characteristics, and examples of functional vs. non-functional requirements.  
   - Use a comparison chart (side-by-side).  

3. **Guided Practice (10 min):**  
   - Provide students with a short system description (e.g., an online shopping website).  
   - Ask them to identify at least 2 functional and 2 non-functional requirements.  

4

Got it! You want me to take those rough notes and turn them into a structured **lesson plan section** that could fit into a teaching session. I’ll create a clear, teacher-friendly lesson plan format with objectives, activities, and examples based on the content you provided.  

---

# Lesson Plan Section: Functional and Non-Functional Requirements  

### Lesson Title:  
Understanding Functional vs. Non-Functional Requirements  

### Duration:  
30–40 minutes  

### Learning Objectives:  
By the end of this lesson, students will be able to:  
1. Define and distinguish between functional and non-functional requirements.  
2. Identify examples of both types of requirements in software systems.  
3. Explain how requirements are documented and tested.  
4. Recognize the role of functional and non-functional requirements in system quality.  

---

### Teaching Content:  

**1. Documentation of Requirements**  
- Requirements can be captured in:  
  - Use-case diagrams  
  - Quality attributes documentation  
- Importance: Provides a shared understanding between stakeholders and developers.  

**2. Testing of Requirements**  
- **Functional Testing:**  
  - Component, API, Unit, Integration, and UI testing  
  - Conducted before non-functional testing  
- **Non-Functional Testing:**  
  - Performance, usability, security testing, etc.  
  - Conducted after functional testing  

**3. Functional vs. Non-Functional Requirements**  
- **Functional Requirements:** Define *what the system should do*.  
  - Example: “The system must assign a unique tracking number to every shipment.”  
  - Example: “The system shall display the due date of payment as MM/DD/YY.”  

- **Non-Functional Requirements:** Define *how the system performs or behaves*.  
  - Example: “The system will print the monthly report quickly.”  
  - Example: “Invalid login attempts must be recorded and sent to security administrators.”  

---

### Teaching Strategies & Activities:  

1. **Direct Instruction (10 min):**  
   - Present definitions and examples of functional and non-functional requirements.  
   - Use a simple diagram to show where each type fits in the software development lifecycle.  

2. **Guided Practice (10 min):**  
   - Provide students with a list of requirements.  
   - Ask them to classify each as functional or non-functional.  

3. **Group Activity (10–15 min):**  
   - In small groups, students create 2 functional and 2 non-functional requirements

Great! I’ll take your raw notes and convert them into a **structured lesson plan section** that you can use in class.  

---

# Lesson Plan Section: Functional vs. Non-Functional Requirements  

### Topic: Understanding and Differentiating Functional and Non-Functional Requirements  

**Learning Objectives:**  
By the end of this lesson, students will be able to:  
1. Define functional and non-functional requirements.  
2. Identify examples of each type of requirement.  
3. Apply the concepts to real-world scenarios by analyzing system requirements.  
4. Practice functional decomposition or Work Breakdown Structures (WBS).  

---

### Lesson Content  

**1. Introduction (5 minutes)**  
- Briefly explain the importance of requirements in system development.  
- Define:  
  - **Functional Requirements**: What the system should do (specific behaviors, tasks, or functions).  
  - **Non-Functional Requirements**: How the system performs (quality attributes such as speed, security, usability).  

---

**2. Examples and Classification (10 minutes)**  

**Example 1:**  
- Requirement: *The system must print the monthly report quickly.*  
  - Functional: *Print the monthly report*  
  - Non-Functional: *Quickly*  

**Example 2:**  
- Requirement: *The system must assign a unique tracking number to every shipment.*  
  - Functional: *Assign a unique tracking number*  

**Example 3:**  
- Requirement: *The system shall display the due date of payment as MM/DD/YY.*  
  - Functional: *Display the due date of payment*  

**Example 4:**  
- Requirement: *Invalid login attempts must be recorded and sent to security administrators.*  
  - Functional: *Record invalid login attempts*  
  - Non-Functional: *Security requirement (send to administrators)*  

*Class Activity:* Ask students to classify each requirement as functional or non-functional.  

---

**3. Workshop Activity (20 minutes)**  
- **Task:** In groups of 2–10, visit the website: [MFU School of Information Technology](https://en.mfu.ac.th/schools/school-of-information-technology-1.html).  
- **Instructions:**  
  1. Explore the website and identify possible system requirements.  
  2. Perform **functional decomposition** or create a **Work Breakdown Structure (WBS)** for one system or process you identify.  
  3. Prepare a short presentation of your group